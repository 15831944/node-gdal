<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/collections/feature_fields.cpp - node-gdal</title>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/css/lucid.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-skin-sam">
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
        
	    <img alt="node-gdal" src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/df/GDALLogoColor.svg/200px-GDALLogoColor.svg.png" style="max-height: 65%;" title="node-gdal">
        
            node-gdal
        </h1>
	<div class="nav">
            <li class="divider-vertical"></li>
            <li>
                <p class="navbar-text">
                    API Docs for Version: <b>0.6.0</b>
                </p>
            </li>
        </div>
        <form class="navbar-form pull-right" style="line-height: 40px; height: 40px;">
            <input style="margin-top: 0;" type="text" class="search-query" placeholder="Search for classes/modules..." data-obj='["classes/Constants (DCAP)", "classes/Constants (DMD)", "classes/Constants (GCI)", "classes/Constants (GDT)", "classes/Constants (GRA)", "classes/Constants (ODsC)", "classes/Constants (OFT)", "classes/Constants (OJ)", "classes/Constants (OLC)", "classes/Constants (wkbByteOrder)", "classes/Constants (wkbGeometryType)", "classes/Constants (wkbVariant)", "classes/gdal", "classes/gdal.CoordinateTransformation", "classes/gdal.Dataset", "classes/gdal.DatasetBands", "classes/gdal.DatasetLayers", "classes/gdal.Driver", "classes/gdal.Envelope", "classes/gdal.Envelope3D", "classes/gdal.Feature", "classes/gdal.FeatureDefn", "classes/gdal.FeatureDefnFields", "classes/gdal.FeatureFields", "classes/gdal.FieldDefn", "classes/gdal.GDALDrivers", "classes/gdal.Geometry", "classes/gdal.GeometryCollection", "classes/gdal.GeometryCollectionChildren", "classes/gdal.Layer", "classes/gdal.LayerFeatures", "classes/gdal.LayerFields", "classes/gdal.LinearRing", "classes/gdal.LineString", "classes/gdal.LineStringPoints", "classes/gdal.MultiLineString", "classes/gdal.MultiPoint", "classes/gdal.MultiPolygon", "classes/gdal.Point", "classes/gdal.Polygon", "classes/gdal.PolygonRings", "classes/gdal.RasterBand", "classes/gdal.RasterBandOverviews", "classes/gdal.RasterBandPixels", "classes/gdal.SpatialReference"]'>
        </form>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="span3">
	    <div>
    <div id="sidebar">
    <div id="classes">
        <ul id="api-classes" class="nav nav-list">
            
                <li><a href="../classes/Constants (DCAP).html">Constants (DCAP)</a></li>
            
                <li><a href="../classes/Constants (DMD).html">Constants (DMD)</a></li>
            
                <li><a href="../classes/Constants (GCI).html">Constants (GCI)</a></li>
            
                <li><a href="../classes/Constants (GDT).html">Constants (GDT)</a></li>
            
                <li><a href="../classes/Constants (GRA).html">Constants (GRA)</a></li>
            
                <li><a href="../classes/Constants (ODsC).html">Constants (ODsC)</a></li>
            
                <li><a href="../classes/Constants (OFT).html">Constants (OFT)</a></li>
            
                <li><a href="../classes/Constants (OJ).html">Constants (OJ)</a></li>
            
                <li><a href="../classes/Constants (OLC).html">Constants (OLC)</a></li>
            
                <li><a href="../classes/Constants (wkbByteOrder).html">Constants (wkbByteOrder)</a></li>
            
                <li><a href="../classes/Constants (wkbGeometryType).html">Constants (wkbGeometryType)</a></li>
            
                <li><a href="../classes/Constants (wkbVariant).html">Constants (wkbVariant)</a></li>
            
                <li><a href="../classes/gdal.html">gdal</a></li>
            
                <li><a href="../classes/gdal.CoordinateTransformation.html">gdal.CoordinateTransformation</a></li>
            
                <li><a href="../classes/gdal.Dataset.html">gdal.Dataset</a></li>
            
                <li><a href="../classes/gdal.DatasetBands.html">gdal.DatasetBands</a></li>
            
                <li><a href="../classes/gdal.DatasetLayers.html">gdal.DatasetLayers</a></li>
            
                <li><a href="../classes/gdal.Driver.html">gdal.Driver</a></li>
            
                <li><a href="../classes/gdal.Envelope.html">gdal.Envelope</a></li>
            
                <li><a href="../classes/gdal.Envelope3D.html">gdal.Envelope3D</a></li>
            
                <li><a href="../classes/gdal.Feature.html">gdal.Feature</a></li>
            
                <li><a href="../classes/gdal.FeatureDefn.html">gdal.FeatureDefn</a></li>
            
                <li><a href="../classes/gdal.FeatureDefnFields.html">gdal.FeatureDefnFields</a></li>
            
                <li><a href="../classes/gdal.FeatureFields.html">gdal.FeatureFields</a></li>
            
                <li><a href="../classes/gdal.FieldDefn.html">gdal.FieldDefn</a></li>
            
                <li><a href="../classes/gdal.GDALDrivers.html">gdal.GDALDrivers</a></li>
            
                <li><a href="../classes/gdal.Geometry.html">gdal.Geometry</a></li>
            
                <li><a href="../classes/gdal.GeometryCollection.html">gdal.GeometryCollection</a></li>
            
                <li><a href="../classes/gdal.GeometryCollectionChildren.html">gdal.GeometryCollectionChildren</a></li>
            
                <li><a href="../classes/gdal.Layer.html">gdal.Layer</a></li>
            
                <li><a href="../classes/gdal.LayerFeatures.html">gdal.LayerFeatures</a></li>
            
                <li><a href="../classes/gdal.LayerFields.html">gdal.LayerFields</a></li>
            
                <li><a href="../classes/gdal.LinearRing.html">gdal.LinearRing</a></li>
            
                <li><a href="../classes/gdal.LineString.html">gdal.LineString</a></li>
            
                <li><a href="../classes/gdal.LineStringPoints.html">gdal.LineStringPoints</a></li>
            
                <li><a href="../classes/gdal.MultiLineString.html">gdal.MultiLineString</a></li>
            
                <li><a href="../classes/gdal.MultiPoint.html">gdal.MultiPoint</a></li>
            
                <li><a href="../classes/gdal.MultiPolygon.html">gdal.MultiPolygon</a></li>
            
                <li><a href="../classes/gdal.Point.html">gdal.Point</a></li>
            
                <li><a href="../classes/gdal.Polygon.html">gdal.Polygon</a></li>
            
                <li><a href="../classes/gdal.PolygonRings.html">gdal.PolygonRings</a></li>
            
                <li><a href="../classes/gdal.RasterBand.html">gdal.RasterBand</a></li>
            
                <li><a href="../classes/gdal.RasterBandOverviews.html">gdal.RasterBandOverviews</a></li>
            
                <li><a href="../classes/gdal.RasterBandPixels.html">gdal.RasterBandPixels</a></li>
            
                <li><a href="../classes/gdal.SpatialReference.html">gdal.SpatialReference</a></li>
            
        </ul>
    </div>
    </div>
</div>

        </div>
        <div class="span9">
                <form id="options-form" class="form-inline pull-right">
        Show:
        <label for="api-show-inherited" class="checkbox">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected" class="checkbox">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private" class="checkbox">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated" class="checkbox">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </form>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <div class="page-header">
    <h1>src/collections/feature_fields.cpp <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
#include &quot;../gdal_common.hpp&quot;
#include &quot;../gdal_feature.hpp&quot;
#include &quot;../utils/fast_buffer.hpp&quot;
#include &quot;feature_fields.hpp&quot;

namespace node_gdal {

Persistent&lt;FunctionTemplate&gt; FeatureFields::constructor;

void FeatureFields::Initialize(Handle&lt;Object&gt; target)
{
	NanScope();

	Local&lt;FunctionTemplate&gt; lcons = NanNew&lt;FunctionTemplate&gt;(FeatureFields::New);
	lcons-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);
	lcons-&gt;SetClassName(NanNew(&quot;FeatureFields&quot;));

	NODE_SET_PROTOTYPE_METHOD(lcons, &quot;toString&quot;, toString);
	NODE_SET_PROTOTYPE_METHOD(lcons, &quot;toObject&quot;, toObject);
	NODE_SET_PROTOTYPE_METHOD(lcons, &quot;toArray&quot;, toArray);
	NODE_SET_PROTOTYPE_METHOD(lcons, &quot;count&quot;, count);
	NODE_SET_PROTOTYPE_METHOD(lcons, &quot;get&quot;, get);
	NODE_SET_PROTOTYPE_METHOD(lcons, &quot;getNames&quot;, getNames);
	NODE_SET_PROTOTYPE_METHOD(lcons, &quot;set&quot;, set);
	NODE_SET_PROTOTYPE_METHOD(lcons, &quot;reset&quot;, reset);
	NODE_SET_PROTOTYPE_METHOD(lcons, &quot;indexOf&quot;, indexOf);

	ATTR_DONT_ENUM(lcons, &quot;feature&quot;, featureGetter, READ_ONLY_SETTER);

	target-&gt;Set(NanNew(&quot;FeatureFields&quot;), lcons-&gt;GetFunction());

	NanAssignPersistent(constructor, lcons);
}

FeatureFields::FeatureFields()
	: ObjectWrap()
{}

FeatureFields::~FeatureFields()
{}

/**
 * An encapsulation of all field data that makes up a {{#crossLink &quot;gdal.Feature&quot;}}Feature{{/crossLink}}.
 *
 * @class gdal.FeatureFields
 */
NAN_METHOD(FeatureFields::New)
{
	NanScope();

	if (!args.IsConstructCall()) {
		NanThrowError(&quot;Cannot call constructor as function, you need to use &#x27;new&#x27; keyword&quot;);
		NanReturnUndefined();
	}
	if (args[0]-&gt;IsExternal()) {
		Local&lt;External&gt; ext = args[0].As&lt;External&gt;();
		void* ptr = ext-&gt;Value();
		FeatureFields *f =  static_cast&lt;FeatureFields *&gt;(ptr);
		f-&gt;Wrap(args.This());
		NanReturnValue(args.This());
	} else {
		NanThrowError(&quot;Cannot create FeatureFields directly&quot;);
		NanReturnUndefined();
	}
}

Handle&lt;Value&gt; FeatureFields::New(Handle&lt;Value&gt; layer_obj)
{
	NanEscapableScope();

	FeatureFields *wrapped = new FeatureFields();

	v8::Handle&lt;v8::Value&gt; ext = NanNew&lt;External&gt;(wrapped);
	v8::Handle&lt;v8::Object&gt; obj = NanNew(FeatureFields::constructor)-&gt;GetFunction()-&gt;NewInstance(1, &amp;ext);
	obj-&gt;SetHiddenValue(NanNew(&quot;parent_&quot;), layer_obj);

	return NanEscapeScope(obj);
}

NAN_METHOD(FeatureFields::toString)
{
	NanScope();
	NanReturnValue(NanNew(&quot;FeatureFields&quot;));
}

inline bool setField(OGRFeature* f, int field_index, Handle&lt;Value&gt; val){
	if (val-&gt;IsInt32()) {
		f-&gt;SetField(field_index, val-&gt;Int32Value());
	} else if (val-&gt;IsNumber()) {
		f-&gt;SetField(field_index, val-&gt;NumberValue());
	} else if (val-&gt;IsString()) {
		std::string str = *NanUtf8String(val);
		f-&gt;SetField(field_index, str.c_str());
	} else if(val-&gt;IsNull() || val-&gt;IsUndefined()) {
		f-&gt;UnsetField(field_index);
	} else {
		return true;
	}
	return false;
}

/**
 * Sets feature field(s).
 *
 * @example
 * &#x60;&#x60;&#x60;
 * // most-efficient, least flexible. requires you to know the ordering of the fields:
 * feature.fields.set([&#x27;Something&#x27;]);
 * feature.fields.set(0, &#x27;Something&#x27;);
 *
 * // most flexible.
 * feature.fields.set({name: &#x27;Something&#x27;});
 * feature.fields.set(&#x27;name&#x27;, &#x27;Something&#x27;);
 * &#x60;&#x60;&#x60;
 *
 * @method set
 * @throws Error
 * @param {String|Integer} key Field name or index
 * @param {mixed} value
 */
NAN_METHOD(FeatureFields::set)
{
	NanScope();
	int field_index;
	unsigned int i, n, n_fields_set;

	Handle&lt;Object&gt; parent = args.This()-&gt;GetHiddenValue(NanNew(&quot;parent_&quot;)).As&lt;Object&gt;();
	Feature *f = ObjectWrap::Unwrap&lt;Feature&gt;(parent);
	if (!f-&gt;get()) {
		NanThrowError(&quot;Feature object already destroyed&quot;);
		NanReturnUndefined();
	}

	if(args.Length() == 1) {
		if(args[0]-&gt;IsArray()) {
			//set([])
			Handle&lt;Array&gt; values = args[0].As&lt;Array&gt;();

			n = f-&gt;get()-&gt;GetFieldCount();
			if(values-&gt;Length() &lt; n) {
				n = values-&gt;Length();
			}

			for (i = 0; i &lt; n; i++) {
				Handle&lt;Value&gt; val = values-&gt;Get(i);
				if(setField(f-&gt;get(), i, val)){
					NanThrowError(&quot;Unsupported type of field value&quot;);
					NanReturnUndefined();
				}
			}

			NanReturnValue(NanNew&lt;Integer&gt;(n));
		} else if (args[0]-&gt;IsObject()) {
			//set({})
			Handle&lt;Object&gt; values = args[0].As&lt;Object&gt;();

			n = f-&gt;get()-&gt;GetFieldCount();
			n_fields_set = 0;

			for (i = 0; i &lt; n; i++) {
				//iterate through field names from field defn,
				//grabbing values from passed object, if not undefined

				OGRFieldDefn* field_def = f-&gt;get()-&gt;GetFieldDefnRef(i);

				const char* field_name = field_def-&gt;GetNameRef();

				field_index = f-&gt;get()-&gt;GetFieldIndex(field_name);

				//skip value if field name doesnt exist
				//both in the feature definition and the passed object
				if (field_index == -1 || !values-&gt;HasOwnProperty(NanNew(field_name))) {
					continue;
				}

				Handle&lt;Value&gt; val = values-&gt;Get(NanNew(field_name));
				if (setField(f-&gt;get(), field_index, val)) {
					NanThrowError(&quot;Unsupported type of field value&quot;);
					NanReturnUndefined();
				}

				n_fields_set++;
			}

			NanReturnValue(NanNew&lt;Integer&gt;(n_fields_set));
		} else {
			NanThrowError(&quot;Method expected an object or array&quot;);
			NanReturnUndefined();
		}

	} else if(args.Length() == 2) {
		//set(name|index, value)
		ARG_FIELD_ID(0, f-&gt;get(), field_index);

		//set field value
		if (setField(f-&gt;get(), field_index, args[1])) {
			NanThrowError(&quot;Unsupported type of field value&quot;);
			NanReturnUndefined();
		}

		NanReturnValue(NanNew&lt;Integer&gt;(1));
	} else {
		NanThrowError(&quot;Invalid number of arguments&quot;);
		NanReturnUndefined();
	}
}

/**
 * Resets all fields.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * feature.fields.reset();&#x60;&#x60;&#x60;
 *
 * @method reset
 * @throws Error
 * @param {Object} [values]
 * @param {mixed} value
 */
NAN_METHOD(FeatureFields::reset)
{
	NanScope();
	int field_index;
	unsigned int i, n;

	Handle&lt;Object&gt; parent = args.This()-&gt;GetHiddenValue(NanNew(&quot;parent_&quot;)).As&lt;Object&gt;();
	Feature *f = ObjectWrap::Unwrap&lt;Feature&gt;(parent);
	if (!f-&gt;get()) {
		NanThrowError(&quot;Feature object already destroyed&quot;);
		NanReturnUndefined();
	}

	n = f-&gt;get()-&gt;GetFieldCount();

	if (args.Length() == 0) {
		for (i = 0; i &lt; n; i++) {
			f-&gt;get()-&gt;UnsetField(i);
		}
		NanReturnValue(NanNew&lt;Integer&gt;(n));
	}

	if (!args[0]-&gt;IsObject()) {
		NanThrowError(&quot;fields must be an object&quot;);
		NanReturnUndefined();
	}

	Handle&lt;Object&gt; values = args[0].As&lt;Object&gt;();

	for (i = 0; i &lt; n; i++) {
		//iterate through field names from field defn,
		//grabbing values from passed object

		OGRFieldDefn* field_def = f-&gt;get()-&gt;GetFieldDefnRef(i);

		const char* field_name = field_def-&gt;GetNameRef();

		field_index = f-&gt;get()-&gt;GetFieldIndex(field_name);
		if(field_index == -1) continue;

		Handle&lt;Value&gt; val = values-&gt;Get(NanNew(field_name));
		if(setField(f-&gt;get(), field_index, val)){
			NanThrowError(&quot;Unsupported type of field value&quot;);
			NanReturnUndefined();
		}
	}

	NanReturnValue(NanNew&lt;Integer&gt;(n));
}

/**
 * Returns the number of fields.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * feature.fields.count();&#x60;&#x60;&#x60;
 *
 * @method count
 * @return {Integer}
 */
NAN_METHOD(FeatureFields::count)
{
	NanScope();

	Handle&lt;Object&gt; parent = args.This()-&gt;GetHiddenValue(NanNew(&quot;parent_&quot;)).As&lt;Object&gt;();
	Feature *f = ObjectWrap::Unwrap&lt;Feature&gt;(parent);
	if (!f-&gt;get()) {
		NanThrowError(&quot;Feature object already destroyed&quot;);
		NanReturnUndefined();
	}

	NanReturnValue(NanNew&lt;Integer&gt;(f-&gt;get()-&gt;GetFieldCount()));
}

/**
 * Returns the index of a field, given its name.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * var index = feature.fields.indexOf(&#x27;field&#x27;);&#x60;&#x60;&#x60;
 *
 * @method indexOf
 * @param {String} name
 * @return {Integer} Index or, &#x60;-1&#x60; if it cannot be found.
 */
NAN_METHOD(FeatureFields::indexOf)
{
	NanScope();

	Handle&lt;Object&gt; parent = args.This()-&gt;GetHiddenValue(NanNew(&quot;parent_&quot;)).As&lt;Object&gt;();
	Feature *f = ObjectWrap::Unwrap&lt;Feature&gt;(parent);
	if (!f-&gt;get()) {
		NanThrowError(&quot;Feature object already destroyed&quot;);
		NanReturnUndefined();
	}

	std::string name(&quot;&quot;);
	NODE_ARG_STR(0, &quot;field name&quot;, name);

	NanReturnValue(NanNew&lt;Integer&gt;(f-&gt;get()-&gt;GetFieldIndex(name.c_str())));
}

/**
 * Outputs the field data as a pure JS object.
 *
 * @throws Error
 * @method toObject
 * @return {Object}
 */
NAN_METHOD(FeatureFields::toObject)
{
	NanScope();

	Handle&lt;Object&gt; parent = args.This()-&gt;GetHiddenValue(NanNew(&quot;parent_&quot;)).As&lt;Object&gt;();
	Feature *f = ObjectWrap::Unwrap&lt;Feature&gt;(parent);
	if (!f-&gt;get()) {
		NanThrowError(&quot;Feature object already destroyed&quot;);
		NanReturnUndefined();
	}

	Local&lt;Object&gt; obj = NanNew&lt;Object&gt;();

	int n = f-&gt;get()-&gt;GetFieldCount();
	for(int i = 0; i &lt; n; i++) {

		//get field name
		OGRFieldDefn *field_def = f-&gt;get()-&gt;GetFieldDefnRef(i);
		const char *key = field_def-&gt;GetNameRef();
		if (!key) {
			NanThrowError(&quot;Error getting field name&quot;);
			NanReturnUndefined();
		}

		//get field value
		Handle&lt;Value&gt; val = FeatureFields::get(f-&gt;get(), i);
		if (val.IsEmpty()) {
			NanReturnUndefined(); //get method threw an exception
		}

		obj-&gt;Set(NanNew(key), val);
	}
	NanReturnValue(obj);
}

/**
 * Outputs the field values as a pure JS array.
 *
 * @throws Error
 * @method toArray
 * @return {Array}
 */
NAN_METHOD(FeatureFields::toArray)
{
	NanScope();

	Handle&lt;Object&gt; parent = args.This()-&gt;GetHiddenValue(NanNew(&quot;parent_&quot;)).As&lt;Object&gt;();
	Feature *f = ObjectWrap::Unwrap&lt;Feature&gt;(parent);
	if (!f-&gt;get()) {
		NanThrowError(&quot;Feature object already destroyed&quot;);
		NanReturnUndefined();
	}

	int n = f-&gt;get()-&gt;GetFieldCount();
	Handle&lt;Array&gt; array = NanNew&lt;Array&gt;(n);

	for(int i = 0; i &lt; n; i++) {
		//get field value
		Handle&lt;Value&gt; val = FeatureFields::get(f-&gt;get(), i);
		if (val.IsEmpty()) {
			NanReturnUndefined(); //get method threw an exception
		}

		array-&gt;Set(i, val);
	}
	NanReturnValue(array);
}

Handle&lt;Value&gt; FeatureFields::get(OGRFeature *f, int field_index)
{
	//#throws : caller must check if return_val.IsEmpty() and bail out if true
	NanEscapableScope();

	if(!f-&gt;IsFieldSet(field_index)) return NanEscapeScope(NanNull());

	OGRFieldDefn *field_def = f-&gt;GetFieldDefnRef(field_index);
	switch(field_def-&gt;GetType()) {
		case OFTInteger:
			return NanEscapeScope(NanNew&lt;Integer&gt;(f-&gt;GetFieldAsInteger(field_index)));
		case OFTReal:
			return NanEscapeScope(NanNew&lt;Number&gt;(f-&gt;GetFieldAsDouble(field_index)));
		case OFTString:
			return NanEscapeScope(SafeString::New(f-&gt;GetFieldAsString(field_index)));
		case OFTIntegerList:
			return NanEscapeScope(getFieldAsIntegerList(f, field_index));
		case OFTRealList:
			return NanEscapeScope(getFieldAsDoubleList(f, field_index));
		case OFTStringList:
			return NanEscapeScope(getFieldAsStringList(f, field_index));
		case OFTBinary:
			return NanEscapeScope(getFieldAsBinary(f, field_index));
		case OFTDate:
		case OFTTime:
		case OFTDateTime:
			return NanEscapeScope(getFieldAsDateTime(f, field_index));
		default:
			NanThrowError(&quot;Unsupported field type&quot;);
			return NanEscapeScope(NanUndefined());
	}
}

/**
 * Returns a field&#x27;s value.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * value = feature.fields.get(0);
 * value = feature.fields.get(&#x27;field&#x27;);&#x60;&#x60;&#x60;
 *
 * @method get
 * @param {String|Integer} key Feature name or index.
 * @return {mixed|Undefined}
 */
NAN_METHOD(FeatureFields::get)
{
	NanScope();

	Handle&lt;Object&gt; parent = args.This()-&gt;GetHiddenValue(NanNew(&quot;parent_&quot;)).As&lt;Object&gt;();
	Feature *f = ObjectWrap::Unwrap&lt;Feature&gt;(parent);
	if (!f-&gt;get()) {
		NanThrowError(&quot;Feature object already destroyed&quot;);
		NanReturnUndefined();
	}

	if (args.Length() &lt; 1) {
		NanThrowError(&quot;Field index or name must be given&quot;);
		NanReturnUndefined();
	}

	int field_index;
	ARG_FIELD_ID(0, f-&gt;get(), field_index);

	Handle&lt;Value&gt; result = FeatureFields::get(f-&gt;get(), field_index);

	if(result.IsEmpty()) {
		NanReturnUndefined();
	} else {
		NanReturnValue(result);
	}
}

/**
 * Returns a list of field name.
 *
 * @method getNames
 * @throws Error
 * @return {Array} List of field names.
 */
NAN_METHOD(FeatureFields::getNames)
{
	NanScope();

	Handle&lt;Object&gt; parent = args.This()-&gt;GetHiddenValue(NanNew(&quot;parent_&quot;)).As&lt;Object&gt;();
	Feature *f = ObjectWrap::Unwrap&lt;Feature&gt;(parent);
	if (!f-&gt;get()) {
		NanThrowError(&quot;Feature object already destroyed&quot;);
		NanReturnUndefined();
	}

	int n = f-&gt;get()-&gt;GetFieldCount();
	Handle&lt;Array&gt; result = NanNew&lt;Array&gt;(n);

	for(int i = 0; i &lt; n; i++) {

		//get field name
		OGRFieldDefn *field_def = f-&gt;get()-&gt;GetFieldDefnRef(i);
		const char *field_name = field_def-&gt;GetNameRef();
		if (!field_name) {
			NanThrowError(&quot;Error getting field name&quot;);
			NanReturnUndefined();
		}
		result-&gt;Set(i, NanNew(field_name));
	}

	NanReturnValue(result);
}

Handle&lt;Value&gt; FeatureFields::getFieldAsIntegerList(OGRFeature* feature, int field_index)
{
	NanEscapableScope();

	int count_of_values = 0;

	const int *values = feature-&gt;GetFieldAsIntegerList(field_index, &amp;count_of_values);

	Local&lt;Array&gt; return_array = NanNew&lt;Array&gt;(count_of_values);

	for (int index = 0; index &lt; count_of_values; index++) {
		return_array-&gt;Set(index, NanNew&lt;Integer&gt;(values[index]));
	}

	return NanEscapeScope(return_array);
}


Handle&lt;Value&gt; FeatureFields::getFieldAsDoubleList(OGRFeature* feature, int field_index)
{
	NanEscapableScope();

	int count_of_values = 0;

	const double *values = feature-&gt;GetFieldAsDoubleList(field_index, &amp;count_of_values);

	Local&lt;Array&gt; return_array = NanNew&lt;Array&gt;(count_of_values);

	for (int index = 0; index &lt; count_of_values; index++) {
		return_array-&gt;Set(index, NanNew&lt;Number&gt;(values[index]));
	}

	return NanEscapeScope(return_array);
}


Handle&lt;Value&gt; FeatureFields::getFieldAsStringList(OGRFeature* feature, int field_index)
{
	NanEscapableScope();
	char **values = feature-&gt;GetFieldAsStringList(field_index);

	int count_of_values = CSLCount(values);

	Local&lt;Array&gt; return_array = NanNew&lt;Array&gt;(count_of_values);

	for (int index = 0; index &lt; count_of_values; index++) {
		return_array-&gt;Set(index, SafeString::New(values[index]));
	}

	return NanEscapeScope(return_array);
}


Handle&lt;Value&gt; FeatureFields::getFieldAsBinary(OGRFeature* feature, int field_index)
{
	NanEscapableScope();

	int count_of_bytes = 0;

	unsigned char *data = (unsigned char*) feature-&gt;GetFieldAsBinary(field_index, &amp;count_of_bytes);

	if (count_of_bytes &gt; 0) {
		return NanEscapeScope(FastBuffer::New(data, count_of_bytes));
	}

	return NanEscapeScope(NanUndefined());
}


Handle&lt;Value&gt; FeatureFields::getFieldAsDateTime(OGRFeature* feature, int field_index)
{
	NanEscapableScope();

	int year, month, day, hour, minute, second, timezone;

	year = month = day = hour = minute = second = timezone = 0;

	int result = feature-&gt;GetFieldAsDateTime(field_index, &amp;year, &amp;month,
				 &amp;day, &amp;hour, &amp;minute, &amp;second, &amp;timezone);

	if (result == TRUE) {
		Local&lt;Object&gt; hash = NanNew&lt;Object&gt;();

		if (year) {
			hash-&gt;Set(NanNew(&quot;year&quot;), NanNew&lt;Integer&gt;(year));
		}
		if (month) {
			hash-&gt;Set(NanNew(&quot;month&quot;), NanNew&lt;Integer&gt;(month));
		}
		if (day) {
			hash-&gt;Set(NanNew(&quot;day&quot;), NanNew&lt;Integer&gt;(day));
		}
		if (hour) {
			hash-&gt;Set(NanNew(&quot;hour&quot;), NanNew&lt;Integer&gt;(hour));
		}
		if (minute) {
			hash-&gt;Set(NanNew(&quot;minute&quot;), NanNew&lt;Integer&gt;(minute));
		}
		if (second) {
			hash-&gt;Set(NanNew(&quot;second&quot;), NanNew&lt;Integer&gt;(second));
		}
		if (timezone) {
			hash-&gt;Set(NanNew(&quot;timezone&quot;), NanNew&lt;Integer&gt;(timezone));
		}

		return NanEscapeScope(hash);
	} else {
		return NanEscapeScope(NanUndefined());
	}
}

/**
 * Parent feature
 *
 * @readOnly
 * @attribute feature
 * @type {gdal.Feature}
 */
NAN_GETTER(FeatureFields::featureGetter)
{
	NanScope();
	NanReturnValue(args.This()-&gt;GetHiddenValue(NanNew(&quot;parent_&quot;)));
}

} // namespace node_gdal
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/yuidoc-bootstrap.js"></script>
<script>prettyPrint();</script>
</body>
</html>
